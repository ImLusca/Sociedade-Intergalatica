CREATE TABLE app_users (
    userID NUMBER,
    password VARCHAR2(40),
    IdLider CHAR(14),
    CONSTRAINT PK_USERS_TABLE PRIMARY KEY (userID),
    CONSTRAINT FK_USERS_LIDER FOREIGN KEY (IdLider) REFERENCES LIDER(CPI) ON DELETE CASCADE,
    CONSTRAINT CK_USERS_TABLE_CPI CHECK (REGEXP_LIKE(IdLider, '^\d{3}\.\d{3}\.\d{3}-\d{2}$')),
    CONSTRAINT UN_USERS_CPI UNIQUE (IdLider)    
);

CREATE SEQUENCE app_users_seq;

CREATE OR REPLACE PACKAGE app_user_security AS

    FUNCTION get_hash (p_password  IN  VARCHAR2)
        RETURN VARCHAR2;
    
    PROCEDURE add_user (p_username  IN  VARCHAR2,
                      p_password  IN  VARCHAR2);

    PROCEDURE change_password (p_username      IN  VARCHAR2,
                             p_old_password  IN  VARCHAR2,
                             p_new_password  IN  VARCHAR2);

    PROCEDURE valid_user (p_username  IN  VARCHAR2,
                        p_password  IN  VARCHAR2);

    FUNCTION validate_user (p_username  IN  VARCHAR2,
                       p_password  IN  VARCHAR2)
        RETURN BOOLEAN;

END;

CREATE OR REPLACE PACKAGE BODY app_user_security AS

    FUNCTION get_hash (p_password  IN  VARCHAR2) RETURN VARCHAR2 AS

        v_hash VARCHAR2(40);

    BEGIN

        SELECT STANDARD_HASH(p_password, 'MD5') INTO v_hash FROM dual;
        RETURN v_hash;  

    END;

    PROCEDURE add_user (p_username IN  VARCHAR2,
                      p_password  IN  VARCHAR2) AS
                      
    BEGIN
    
        INSERT INTO app_users (
            userID,
            password,
            IdLider
        )
        VALUES (
            app_users_seq.NEXTVAL,
            get_hash(p_password),
            UPPER(p_username)
        );
    
        COMMIT;
        
    EXCEPTION
    
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-20000, 'idLider já registrado');
        
    END;
   
    PROCEDURE change_password (p_username      IN  VARCHAR2,
                             p_old_password  IN  VARCHAR2,
                             p_new_password  IN  VARCHAR2) AS
        v_rowid  ROWID;
    
    BEGIN
    
        SELECT rowid INTO v_rowid FROM app_users    
        WHERE IdLider = UPPER(p_username) AND password = get_hash(p_old_password)
        FOR UPDATE;
        
        UPDATE app_users SET password = get_hash(p_new_password) WHERE rowid = v_rowid;
    
        COMMIT;
        
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RAISE_APPLICATION_ERROR(-20000, 'Invalid username/password.');
    END;

    PROCEDURE valid_user (p_username  IN  VARCHAR2,
                        p_password  IN  VARCHAR2) AS
                        
        v_dummy  VARCHAR2(1);
        
    BEGIN
        SELECT '1' INTO v_dummy FROM app_users
        WHERE IdLider = UPPER(p_username) AND password = get_hash(p_password);
  
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20000, 'Invalid username/password.');
    END;
  
    FUNCTION validate_user (p_username  IN  VARCHAR2,
                            p_password  IN  VARCHAR2) 
        RETURN BOOLEAN AS
  
    BEGIN
        valid_user(p_username, p_password);
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN FALSE;
    END;
  
END;


CREATE TABLE LOG_TABLE (
    userID NUMBER,
    log_time TIMESTAMP,
    message VARCHAR2(30),
    CONSTRAINT PK_LOG_TABLE PRIMARY KEY (userID, log_time),
    CONSTRAINT FK_LOG_TABLE FOREIGN KEY (userID) REFERENCES app_users(userID) ON DELETE SET NULL
);

CREATE OR REPLACE PROCEDURE log_user_action (
    p_userID IN NUMBER,
    p_message IN VARCHAR2
) AS
BEGIN

    INSERT INTO LOG_TABLE (userID, log_time, message) VALUES (p_userID, SYSTIMESTAMP, p_message);

END log_user_action;

-- PRECISA ARRUMAR ESSA FUNÇÃO AQUI, N FAÇO IDEIA OQ TA ACONTECENDO
CREATE OR REPLACE PROCEDURE insert_liders_into_users AS
    TYPE t_cpi IS TABLE OF lider.cpi%TYPE;
    info_lider t_cpi;

BEGIN 
    -- Coleta os CPIs que não existem em app_users
    SELECT L.cpi BULK COLLECT INTO info_lider 
    FROM lider L
    LEFT JOIN app_users A ON A.cpi = L.cpi
    WHERE A.cpi IS NULL;
    
    -- Adiciona os novos registros usando FORALL
    IF info_lider.COUNT > 0 THEN
        FORALL i IN INDICES OF info_lider
            app_user_security.add_user(info_lider(i), 'a' || info_lider(i));
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20002, 'Erro:' || SQLERRM); 
        
END insert_liders_into_users;

begin
    insert_liders_into_users();
end;
    
    
/*

    COMANDANTE

*/

CREATE OR REPLACE PACKAGE GerenciamentoComandante AS
    
    PROCEDURE sair_federacao (p_nome_nacao VARCHAR2, p_federacao VARCHAR2);
    PROCEDURE entrar_federacao (p_nome_nacao VARCHAR2, p_federacao VARCHAR2);
    PROCEDURE criar_federacao_com_nacao (p_nome_federacao VARCHAR2, p_nome_nacao VARCHAR2, p_data_fund DATE DEFAULT SYSDATE);
    PROCEDURE dominancia_planeta (p_planeta PLANETA.ID_ASTRO%TYPE, p_nacao NACAO.nome%TYPE, p_data_ini DATE DEFAULT SYSDATE);
    
END;
-- 3. A) i.

CREATE OR REPLACE PACKAGE BODY GerenciamentoComandante AS

    PROCEDURE sair_federacao (
        p_nome_nacao VARCHAR2,
        p_federacao VARCHAR2
    ) IS
    
        e_naoEncontrado EXCEPTION;
        v_dummy  VARCHAR2(1);
        
    BEGIN
    
        SELECT '1' INTO v_dummy FROM federacao WHERE nome = p_federacao;

        UPDATE nacao SET federacao = NULL WHERE nome = p_nome_nacao;
        
        IF SQL%NOTFOUND THEN 
            RAISE e_naoEncontrado; 
        END IF;
        
    EXCEPTION
        
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20020, 'Essa federação não existe');
        
        WHEN e_naoEncontrado THEN
            RAISE_APPLICATION_ERROR(-20021, 'Essa nação não existe');
    END;

    PROCEDURE entrar_federacao (
        p_nome_nacao VARCHAR2,
        p_federacao VARCHAR2
    ) IS
        
        e_naoEncontrado EXCEPTION;
        v_dummy  VARCHAR2(1);
        
    BEGIN
    
        SELECT '1' INTO v_dummy FROM federacao WHERE nome = p_federacao;
        
        UPDATE nacao SET federacao = p_federacao WHERE nome = p_nome_nacao;
        
         IF SQL%NOTFOUND THEN 
            RAISE e_naoEncontrado; 
        END IF;
        
    EXCEPTION
    
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20000, 'Essa federação não existe');
            
        WHEN e_naoEncontrado THEN
            RAISE_APPLICATION_ERROR(-20021, 'Essa nação não existe');
    END;
    
    --- FICAR ATENTO EM CHECAR SE QUEM ESTÁ FAZENFO ISSO COM A NAÇAO É O LIDER DESSA MESMA NAÇÃO!!
    
    PROCEDURE criar_federacao_com_nacao (
        p_nome_federacao VARCHAR2,
        p_nome_nacao VARCHAR2,
        p_data_fund DATE DEFAULT SYSDATE
    ) IS
        
        e_naoEncontrado EXCEPTION;
    
    BEGIN
    
        INSERT INTO FEDERACAO (NOME, DATA_FUND) VALUES (p_nome_federacao, p_data_fund);
        UPDATE nacao SET federacao = p_nome_federacao WHERE nome = p_nome_nacao;
        
         IF SQL%NOTFOUND THEN 
            RAISE e_naoEncontrado; 
        END IF;
    
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
            RAISE_APPLICATION_ERROR(-20031, 'Federação Já Existe');
            
        WHEN e_naoEncontrado THEN
            RAISE_APPLICATION_ERROR(-20031, 'Nação não encontrada');
    
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Erro:' || SQLERRM);    
    END;

    PROCEDURE dominancia_planeta (
        p_planeta PLANETA.ID_ASTRO%TYPE,
        p_nacao NACAO.nome%TYPE,
        p_data_ini DATE DEFAULT SYSDATE
    ) IS
    
    v_count NUMBER;
    e_ja_dominado EXCEPTION;
    
    BEGIN
        
        SELECT count(*) into v_count FROM dominancia WHERE planeta = p_planeta AND data_fim IS NULL;
        
        IF v_count >= 0 THEN
            RAISE e_ja_dominado;
        END IF;
        
        INSERT INTO dominancia VALUES (p_planeta, p_nacao, p_data_ini, NULL);
        
        UPDATE nacao SET qtd_planetas = qtd_planetas + 1 WHERE nome = p_nacao;
        
    EXCEPTION
    
        WHEN NO_DATA_FOUND THEN 
            RAISE_APPLICATION_ERROR(-20041, 'Planeta já dominado');
            
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Erro:' || SQLERRM);
    END;
END GerenciamentoComandante;

-- relatorio Comandante        

CREATE OR REPLACE PACKAGE RELATORIO_COMANDANTE AS

    -- Define custom types
    TYPE t_planeta_id IS TABLE OF PLANETA.ID_ASTRO%TYPE;
    TYPE t_nacao IS TABLE OF NACAO.NOME%TYPE;
    TYPE t_datas IS TABLE OF DOMINANCIA.DATA_INI%TYPE;
    TYPE t_num IS TABLE OF NUMBER;
    TYPE t_faccao IS TABLE OF FACCAO.NOME%TYPE;
    
    PROCEDURE PLANET_INFORMATION;
    PROCEDURE PLANETAS_PREOCUPANTES (p_cpi_lider LIDER.CPI%TYPE);
    
END RELATORIO_COMANDANTE; 

CREATE OR REPLACE PACKAGE BODY RELATORIO_COMANDANTE AS 

  -- Declare collections
    l_planeta t_planeta_id;
    l_nacao t_nacao;
    l_data_dominacao_ini t_datas;
    l_data_dominacao_fim t_datas;
    l_num_comunidades t_num;
    l_num_especies t_num;
    l_num_habitantes t_num;
    l_num_faccoes t_num;
    l_faccao_majoritaria t_faccao;
    
    TYPE territorio IS TABLE OF estrela.id_estrela%type;
    v_territorio_nacao territorio;

  
    PROCEDURE PLANET_INFORMATION IS
    BEGIN

        -- nacao dominante atual, datas de fim e inicio da ultima dominação
        SELECT
            PLANETA.ID_ASTRO,
            DOMINANCIA.NACAO,
            DOMINANCIA.DATA_INI,
            DOMINANCIA.DATA_FIM
        BULK COLLECT INTO
            l_planeta,
            l_nacao,
            l_data_dominacao_ini,
            l_data_dominacao_fim
        FROM
            PLANETA
        LEFT JOIN DOMINANCIA ON PLANETA.ID_ASTRO = DOMINANCIA.PLANETA
                             AND DOMINANCIA.DATA_FIM IS NULL
        ORDER BY
            PLANETA.ID_ASTRO;
    
        -- quantidades de comunidades, espécies, habitantes e faccoes presentes
        SELECT
            PLANETA.ID_ASTRO,
            COUNT(DISTINCT COMUNIDADE.ESPECIE || COMUNIDADE.NOME), --num comuniades
            COUNT(DISTINCT COMUNIDADE.ESPECIE), --num especies
            COALESCE(SUM(COMUNIDADE.QTD_HABITANTES), 0), -- num habitantes
            COUNT(DISTINCT PARTICIPA.FACCAO), -- num faccoes presentes
            STATS_MODE(PARTICIPA.FACCAO) --faccão majoritária (STATS_MODE uma função que dado um conjunto de valores retorna o valor com maior frequência)
        BULK COLLECT INTO
            l_planeta,
            l_num_comunidades,
            l_num_especies,
            l_num_habitantes,
            l_num_faccoes,
            l_faccao_majoritaria
        FROM
            PLANETA
        LEFT JOIN HABITACAO ON PLANETA.ID_ASTRO = HABITACAO.PLANETA
        LEFT JOIN COMUNIDADE ON HABITACAO.ESPECIE = COMUNIDADE.ESPECIE
                             AND HABITACAO.COMUNIDADE = COMUNIDADE.NOME
                             AND HABITACAO.DATA_FIM IS NULL
        LEFT JOIN PARTICIPA ON PARTICIPA.ESPECIE = COMUNIDADE.ESPECIE
                           AND PARTICIPA.COMUNIDADE = COMUNIDADE.NOME
        GROUP BY
            PLANETA.ID_ASTRO
        ORDER BY
            PLANETA.ID_ASTRO;
    
        -- Print the first 20 planets or fewer if less than 20 found
        FOR i IN 1..LEAST(cardinality(l_planeta), 20) LOOP
                     DBMS_OUTPUT.PUT_LINE('Planeta: ' || l_planeta(i) || 
                                  ', Nacao Dominante Atual: ' || l_nacao(i) ||
                                  ', Data Inicio Dominancia: ' || l_data_dominacao_ini(i) ||
                                  ', Data Fim Dominancia: ' || l_data_dominacao_fim(i) ||
                                  ', Numero de Comunidades: ' || l_num_comunidades(i) ||
                                  ', Numero de Habitantes: ' || l_num_habitantes(i) ||
                                  ', Numero de especies: ' || l_num_especies(i) ||
                                  ', Numero de Faccoes: ' || l_num_faccoes(i) ||
                                  ', Faccao Majoritaria: ' || l_faccao_majoritaria(i));
        END LOOP;
    
        EXCEPTION
            
            WHEN SUBSCRIPT_BEYOND_COUNT THEN
                RAISE_APPLICATION_ERROR(-20051, 'Elemento não propriamente inicializado');
                
            WHEN SUBSCRIPT_OUTSIDE_LIMIT THEN
                RAISE_APPLICATION_ERROR(-20052, 'Número de chaves excedida!');
                
            WHEN COLLECTION_IS_NULL	 THEN
                RAISE_APPLICATION_ERROR(-20053, 'Uninitialized nested table or varray');
                
            WHEN STORAGE_ERROR	 THEN
                RAISE_APPLICATION_ERROR(-20054, 'PL/SQL acabou com a memória')
                
            WHEN OTHERS THEN
                RAISE_APPLICATION_ERROR(-20002, 'Erro:' || SQLERRM);   
    
    END;
        
    PROCEDURE PLANETAS_PREOCUPANTES (
        p_cpi_lider LIDER.CPI%TYPE) AS
    
        TYPE info_dominacao IS RECORD (
            faccao_lider faccao.nome%TYPE,
            planeta_id planeta.id_astro%TYPE,
            faccao_majoritaria faccao.nome%TYPE
        );
        
        TYPE t_info_dominacao IS TABLE OF info_dominacao;
    
        l_info_dominacao t_info_dominacao;
    
    BEGIN
    
        SELECT A.FACCAO, A.PLANETA, B.FACCAO_MAJORITARIA
        BULK COLLECT INTO l_info_dominacao
            FROM
                (SELECT F.NOME AS FACCAO, D.PLANETA AS PLANETA
                    FROM FACCAO F 
                    JOIN NACAO_FACCAO NF ON F.NOME = NF.FACCAO
                    JOIN DOMINANCIA D ON NF.NACAO = D.NACAO
                    WHERE F.LIDER = p_cpi_lider) A
        JOIN 
            (SELECT
                    PLANETA.ID_ASTRO AS PLANETA,
                    STATS_MODE(PARTICIPA.FACCAO) AS FACCAO_MAJORITARIA 
            
                FROM
                    PLANETA
                
                LEFT JOIN HABITACAO ON PLANETA.ID_ASTRO = HABITACAO.PLANETA
                              AND HABITACAO.DATA_FIM IS NULL
                LEFT JOIN PARTICIPA ON PARTICIPA.ESPECIE = HABITACAO.ESPECIE
                                   AND PARTICIPA.COMUNIDADE = HABITACAO.COMUNIDADE
                GROUP BY
                    PLANETA.ID_ASTRO) B
        ON A.PLANETA = B.PLANETA;
        
        FOR i IN 1..l_info_dominacao.COUNT LOOP
            IF l_info_dominacao(i).faccao_lider <> l_info_dominacao(i).faccao_majoritaria THEN
                DBMS_OUTPUT.PUT_LINE('Planeta: ' || l_info_dominacao(i).planeta_id || 'tem faccão majoritária diferente da sua faccão!';
            END IF;
        END LOOP;
    
    EXCEPTION
        
        WHEN SUBSCRIPT_BEYOND_COUNT THEN
            RAISE_APPLICATION_ERROR(-20051, 'Elemento não propriamente inicializado');
            
        WHEN SUBSCRIPT_OUTSIDE_LIMIT THEN
            RAISE_APPLICATION_ERROR(-20052, 'Número de chaves excedida!');
            
        WHEN COLLECTION_IS_NULL	 THEN
            RAISE_APPLICATION_ERROR(-20053, 'Uninitialized nested table or varray');
            
        WHEN STORAGE_ERROR	 THEN
            RAISE_APPLICATION_ERROR(-20054, 'PL/SQL acabou com a memória')
            
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20002, 'Erro:' || SQLERRM);   
    
    END PLANETAS_PREOCUPANTES;
    
    FUNCTION distancia (
        estrela1 estrela.id_estrela%TYPE,
        estrela2 estrela.id_estrela%TYPE )
    RETURN NUMBER IS
    
        dist NUMBER;
    
        TYPE coordenadas IS RECORD (
            X NUMBER,
            Y NUMBER,
            Z NUMBER
        );
    
        coord_estrela1 coordenadas;
        coord_estrela2 coordenadas;
   
    BEGIN 
        
    SELECT X, Y, Z INTO coord_estrela1
        FROM estrela
        WHERE id_estrela = estrela1;
    
     SELECT X, Y, Z INTO coord_estrela2
        FROM estrela
        WHERE id_estrela = estrela2;
        
    dist := SQRT(POWER(coord_estrela1.X - coord_estrela2.X, 2) + POWER(coord_estrela1.Y - coord_estrela2.Y, 2) + POWER(coord_estrela1.Z - coord_estrela2.Z, 2));
         
    RETURN dist;
        
    EXCEPTION
    
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20001, 'No data found');
            
    END distancia;
    
    FUNCTION get_potential_planets RETURN SYS_REFCURSOR IS
        potential_planets_cursor SYS_REFCURSOR;
    BEGIN
        OPEN potential_planets_cursor FOR
            SELECT DISTINCT 
                p.ID_ASTRO AS planeta, 
                p.MASSA AS massa, 
                p.RAIO AS raio, 
                p.CLASSIFICACAO AS classificacao, 
                s.NOME AS nome_sistema
            FROM 
                SISTEMA s
                JOIN ORBITA_PLANETA op ON s.ESTRELA = op.ESTRELA
                JOIN PLANETA p ON op.PLANETA = p.ID_ASTRO
                LEFT JOIN DOMINANCIA d ON p.ID_ASTRO = d.PLANETA
            WHERE 
                p.ID_ASTRO NOT IN (
                    SELECT d.PLANETA
                    FROM DOMINANCIA d
                    WHERE d.DATA_FIM IS NULL
                );
        RETURN potential_planets_cursor;
    END get_potential_planets;

END RELATORIO_COMANDANTE; 


-- lider: faccao majoritária no planeta que eu domino é a mesma que a minha?
 
CREATE OR REPLACE 

CREATE OR REPLACE 
